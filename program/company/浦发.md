浦发上机笔试、面试题：
2018-11，上海，总行：
猴子吃桃

```python
def sumPeach(day,n):
    # 每天吃一半加一个。
    # day:剩n个时候的是第几天，n:最后一天剩下的个数。
    count = n
   	for i in range(day-1,0,-1):
        count = (count+1)*2
    return count
```

输入一段话，输出字的个数

[中文在unicode中的分区代码段](https://segmentfault.com/q/1010000007898150)

```python
def sumOfWords(s):
    # 输出字符串的单词个数
    s1 = s.strip() # 去掉开头结束的空格
    index = 0
    count = 0
    while index < len(s1):
        while s1[index] != ' ':
            index += 1
            if index == len(s1):
                break
        count += 1
        if index == len(s1):
            break
        while s1[index] == ' ':
            index += 1
    return count
	# 利用内置函数
	# return len(list(s.split()))

def count_Chinese(s):
    # 统计文本中的汉字个数
    # 中文常用字的范围是：[\u4e00,\u9fa5]
    count = 0
    for i in s:
        if '\u4e00' <= i <= '\u9fa5':
        # if i.isalpha() and '\u4e00' <= i <= '\u9fa5':
            count += 1
    return count
```

非完全平方数的判断

```python
import math
def isSqr(n):
	a = int((math.sqrt(n))
	return a*a == n
```
2019-04：
面试题：error和exception的区别

```
python3-语法错误和异常：
	语法错误：一般是指书写代码时出现的错误。解析错误。
	异常：当语法没有发生错误时，运行期间检测的错误被称为异常。
```

JAVA程序链接数据库
了解什么框架
动态规划算法题
数据库事务 隔离级别 数组和链表的区别  

```
数据库事务：逻辑上对数据的一组操作
隔离级别：读未提交、读提交、可重复读、串行化（serializable）
数组和链表的区别：
	存储结构：数组是顺序存储，链表是链式存储。
	元素之间的位置关系：数组是依次顺序存放，链表是通过指针指示下一个元素的位置。
	操作：数组的顺序查找和随机存取比较简单，链表的插入和删除比较简单，不要移动元素。
	相同点：两者都是线性结构，实现数据的顺序存储。
```

笔试题：输入一个数n，计算1（12）（123）...（12..n）[**大数阶乘的和？**]

```python
def factoria(N):
	# 简单实现
	a = 1
	for i in range(2,N+1):
		a *= i
	return a
def factoria2(N):
	# 分治法实现大数阶乘,空间换时间
	N2 = N
	a = list(range(1,N+1))
	while N2 > 1:
		N1 = N2%2
		N2 = N2//2+N1
		for i in range(N2-N1):
			a[i] *=a[N2+i]
		a = a[0:N2]
	return a[0]
def sumOfN(n):
    i = 1 
    m = 0
    count = 0
    while i <= n:
        m = m*10 + i
        count += m
        i += 1
    return count
```
一个字符串的连续子串例如abc，子串有a，b，c，ab，bc
```python
def cut(s):
	res = set()
	for i in range(len(s)-1):
		for j in range(len(s)-i):
            tmp = s[j:j+i+1]
            if tmp not in res:
				res.add(tmp)
   	# res.remove(s)
	return res
# def cut(s):
#     res = []
#     for i in range(len(s)):
#         for j in range(i+1,len(s)+1):
#             res.append(s[i:j])
#     res.remove(s)
#     return res
```
100以内的完数:如果一个数恰好等于它的因子之和，则称该数为“完全数”，又称完美数或完备数 

[完数](https://www.jianshu.com/p/46a2075c3f5c)

```python
def wonderfulNum(num):
	res = []
	for divisor in range(1,num+1):
		tmp = []
		for dividend in range(1,divisior):
			if divisior%dividend == 0:
				tmp.append(divisidend)
		tmpSum = sum(tmp)
		if tmpSum == divisor:
			res.append(divisor)
	return res
```
2019-04 西安 系统开发：
三道题，50分钟。
机试题：
数组元素位置交换

```python
def swapIndex(nums,n,m):
    if n >= len(nums) or m >= len(nums):
        return 
    tmp = nums[n]
    nums[n] = nums[m]
    nums[m] = tmp
    return nums
```

字符串反转

```python
def reverse(s):
	# return s[::-1] # 采用内置函数
	ans = ''
	for i in range(len(s)-1,-1,-1):
		ans += s[i]
	return ans
```
约瑟夫环问题

[约瑟夫环](https://blog.csdn.net/qq_39338979/article/details/83386549)

```python
def Joseph(n,m):
    # n:人数
    # m:数到m的人退出
    # 返回只剩一人时的序号
    # ans：退出的顺序
    a = [i for i in range(1,n+1)]
    ans = []
    while len(a) > 1:
        if len(a) >= m:
            ans.append(a[m-1])
            a = a[m:]+a[:m-1]
        else:
            if (m%len(a)-1) != -1:
                ans.append(a[m%len(a)-1])
                a = a[m%len(a):]+a[:m%len(a)-1]
            else:
                ans.append(a[m%len(a)-1])
                a = a[:m%len(a)-1]
    return a[0],ans
```
面试题：数据库，框架，**求反码**。

```
最高位为符号位，剩下位表示大小。
原码：符号位以外按照正常计算二进制码
反码：正数的反码等于原码，负数的反码是原码除符号位，按位取反
补码：正数的补码等于原码，负数的补码等于反码+1
```

2018-10：
机试题：
一个分段函数，根据x的范围计算y并输出；
输入两个字符串，要求输出第一个字符串中有但第二个没有的，重复的只输出第一个；

```python
def findStr(s1,s2):
	s = set()
	res = ''
	for _,i in enumerate(s1):
		if i not in s2 and i not in s:
			res += i
			s.add(i)
	return res
```
破解密码，明文中的大写字母往后挪5个就是密文—凯撒密码
```python
def encryption(s,k):
	# s：明文，k:移动位数
	str_change = s.lower() # chr(ord(s)^1<<5)
	str_list = list(str_change)
	str_list_encry = str_list
	i = 0
	while i < len(str_list):
		if ord(str_list[i]) < 123-k:
			str_list_encry[i] = chr(ord(str_list[i]) + k )
		else:
			str_list_encry[i] = chr(ord(str_list[i]) + k - 26)
		i += 1
	return str_list_encry
def decrtption(s,k):
	# s:密文，k:移动位数
	str_change = s.lower()
	str_list = list(str_change)
	str_list_decry = str_list
	i = 0
	while i <len(str_list):
		if ord(str_list[i]) >= 97 + k:
			str_list_decry[i] = chr(ord(str_list[i]) - k)
		else:
			str_list_decry[i] = chr(ord(str_list[i]) + 26 - k)
		i += 1
	return str_list_decry
def encryption2(s,k):
    s_n = s.lower()
    ans = ''
    for i in s_n:
        if ord(i) <= 122-k :
            ans += chr(ord(i)+k)
        else:
            ans += chr(ord(i)+k-26)
    return ans
def decrtption2(s,k):
    s_n = s.lower()
    ans = ''
    for i in s_n:
        if ord(i) >= 97+k:
            ans += chr(ord(i)-k)
        else:
            ans += chr(ord(i)-k+26)
    return ans
```
面试题：数据库，项目
2019-04：
机试题：
三维数组求对角线上的元素之和；

```python
def sumDiagonal(grids):
	sum1 = 0
    sum2 = 0
	for i in range(len(grids)):
		sum1 += grids[i][i]
        sum2 += grids[i][2-i]
	return sum1,sum2
```
对于含若干字母和数字的字符串 求其中所有的数字之和；
```python
def sumNum(s):
	if not s:
		return 0
	sum = 0
	for i in s:
        # if '0' <= i <= '9':
		if i.isdigit():
			sum += int(i)
	return sum
```
利用快速排序实现所有奇数在前，偶数在后

```python
def quickSort(nums):
    # 奇数/偶数内部未有序
    if not nums:
        return []
    i = 0
    j = len(nums)-1
    while i <= j:
        while nums[i]%2 != 0:
            i += 1
        while nums[j]%2 == 0:
            j -= 1
        if i <= j:
            tmp = nums[i]
            nums[i] = nums[j]
            nums[j] = tmp
        i += 1
        j -= 1
    return nums
```

面试题：带头结点的单向链表是否有环；python中的数据结构；数据库中的触发器

```
环：快慢指针，快指针一次两步，慢指针一次一步
python中的数据结构：
	常见的：不可变的：元组、字符串、数字（int/float/complex）
		  可变的：列表、集合、字典、字节数组（bytearray）
数据库中的触发器：DDL（数据定义语言）、DML（数据操纵语言）、登录触发器
```

2019-04：
面试题：多线程、线程池、高并发下的任务处理，字符串去重

```
多线程：同时多个线程并发执行。
线程池：内部有多个线程，可以重复使用，当有作业时，会选择一个线程去执行这个作业，执行完后放回线程池。
高并发下的任务处理：通过锁的机制，悲观锁和乐观锁
字符串去重：新建一个空字符串tmp，判断当前字符是否在tmp中，不在，加入，在，下一个
```

机试题：
打印矩形

[三种形状打印](https://www.runoob.com/w3cnote/prints-diamonds-triangles-rectangles.html )

```python
def rectangle(n,m):
    # 打印矩形——实心或空心,n:长，m:宽
    # 空心
    for i in range(n):
        for j in range(m):
            if i != 0 and i != n-1:
                if j == 0 or j == m-1:
                    print('*',end='')
                else:
                    print(' ',end='')
            else:
                print('*',end='')
        print()
    
    # 实心
    for i in range(n):
        for k in range(m):
            print('*',end='')
        print()
```

```python
def print_Triangle(n):
    # 打印等腰直角三角形，n:直角边
    # 输出为倒置的L型，改为L型，第二个循环改为for j in range(i+1):
    for i in range(n):
        for j in range(n-i):
            print('*',end='')
        print()
        
def print_Triangle(n):
    # 打印等边三角形-空心,n:边长
    # 去掉所有的if判断，为实心三角形
    for i in range(n+1):
        for j in range(n-i):
            print(' ', end='')
        for k in range(2*i-1):
            if k == 0 or k == 2*i-2 or i == n:
                if i == n:
                    if k%2 == 0:
                        print('*', end='')
                    else:
                        print(' ', end='')
                else:
                    print('*', end='')
            else:
                print(' ',end='')
        print()
```

```python
def print_rhombus(n):
    # 打印等边菱形，n:边长
    # 去掉if判断为输出实心菱形
    # 打印菱形上半部分
    for i in range(n):
        for j in range(n-i):
            print(' ', end='')
        for k in range(2*i-1):
            if k == 0 or k == 2*i-2:
                print('*', end='')
            else:
                print(' ', end='')
        print()
    # 打印菱形下半部分
    for i in range(n):
        for j in range(i):
            print(' ', end='')
        for k in range(2*(n-i)-1):
            if k == 0 or k == 2*(n-i)-2:
                print('*', end='')
            else:
                print(' ', end='')
        print()
```

求最大公约数

```python
def hcf(x,y):
    # 穷举
    if x > y:
        smaller = y
    else:
        sammller = x
    for i in range(1,smaller+1):
        if (x % i == 0) and (y % i == 0):
            hcf = i
    return hcf
def hcf(x,y):
    # 欧几里得辗转相除法
    if not x:
        return y
    if not y:
        return x
    if x == y:
        return x
    
    while x % y:
        x,y = y, x%y
    return y
def hcf(x,y):
    # 欧几里得辗转相除法，递归实现
    if not y:
        return x
    else:
        return hcf(y,x % y)
```

最小公倍数

```python
def lcm(x,y):
    # 不采用最大公约数计算
    if x > y:
        greater = x
    else:
        greater = y
    while True:
        if (greater % x == 0) and (greater % y == 0):
            lcm = greater
            break
        greater += 1
    return lcm
def lcm(x,y):
    # 采用最大公约数计算
    return x * y // hcf(x,y)
```

2018-11：
机试题：
时间转换

```python
# 时间戳/日期时间字符串/当前时间
import datetime
import time

# 日期时间字符串
st = '2019-08-19 10:15:10'
# 当前日期时间
dt = datetime.datetime.now()
# 当前时间戳
sp = time.time()

def datetime_toString(dt):
    # datetime 转换为字符串
    st_new = dt.strftime('%Y-%m-%d %H:%M:%S')
    return st_new

def string_toDatetime(st):
    # 字符串时间转换为datetime时间
    dt_new = datetime.datetime.strptime(st,"%Y-%m-%d %H:%M:%S")
    return dt_new

def string_toTimestamp(st):
    # 字符串时间转换为时间戳
    sp_new = time.mktime(time.strptime(st,'%Y-%m-%d %H:%M:%S'))
    return sp_new

def timestamp_toString(sp):
    # 将时间戳转换为字符串形式
    st_new = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(sp))
    return st_new

def datetime_toTimestamp(dt):
    # datetime 转换为 时间戳
    sp_new = time.mktime(dt.timetuple())
    return sp_new

def timestamp_toDatetime(sp):
    # 时间戳转换为datetime
    dt_new = datetime.datetime.fromtimestamp(sp)
    return dt_new
```

字符串对称

```python
def is_symmetrical(s):
    # 判断字符串是否对称
    length = len(s)
    for i in range(length//2):
        if s[i] != s[length-i-1]:
            return False
    return True

def longestPalindrome(s):
    # 最长回文子串
    if not s:
        return ''
    res = ''
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    max_len = float('-inf')
    for i in range(n):
        for j in range(i+1):
            if s[i] == s[j] and (i-j <= 2 or dp[j+1][i-1]):
                dp[j][i] = 1
            if dp[j][i] and max_len < i+1-j:
                res = s[j:i+1]
                max_len = i+1-j
    return res
```

喝汽水

```python
def drink_sum(m,n):
    # m:初始空瓶子数量，n:一瓶需要的空瓶数量
    empty_num = m
    while True:
        try:
            if empty_num:
                drink_num = 0
                while empty_num >= n:
                    tmp = empty_num //n
                    drink_num += tmp
                    empty_num = empty_num % 3 + tmp
                if empty_num == n-1:
                    drink_num += 1
                return drink_num
            else:
                return 0
        except:
            break

def person_coke(person,n):
    # 每个和可乐的人会变成两个，然后排在队伍的最后
    # person:初始喝可乐的人，n:第几个喝可乐的人
    for i in range(1,n+1):
        m = person.pop(0)
        person.append(m)
        person.append(m)
    return person[-1]
```

2018-08：
面试题：数据库，常用的排序算法以及快排思想、linux命令

```
常用的排序算法：快、堆、选、希尔、冒、插、归并
快排思想：
```

其他机试题目：

1.给一个数组，一个target值，求数组中俩元素和为target的俩下标

```python
def findIndexofTarget(nums,target):
    # 采用hash法，时间复杂度为O(n)，空间复杂度为O(n)。
    if not nums :
        return [-1,-1]
    n = len(nums)
    lookup = dict()
    for i in range(n):
        tmp = target - nums[i]
        if tmp in lookup:
            return [lookup[tmp],i]
        lookup[nums[i]] = i
```

2.输入一个long 类型的数字，如365141，输出3-6-5-1-4-1

```python
def change_NumType(n):
    # python3中没有long型，只有int型（长整型）
    s = str(n)
    if len(s) == 1:
        return s
    res = ''
    for i in s:
        res = res + i + '-'
    return res[:-1]
```

3.百元百鸡问题（1只公鸡5元 1只母鸡3元 3只小鸡1元 用100元买100只鸡 问公鸡 母鸡 小鸡各有多少只）

```python
def buy():
    # 三种鸡都必须有
    # 按可以购买的数量计算
    count = 0
    res = []
    for x in range(1,20):
        for y in range(1,33):
            z = 100 - x - y
            if (z % 3 == 0) and ((5*x + 3*y + z//3) == 100):
                count += 1
                res.append((x,y,z))
     return res,count
```

4.十进制转二进制

```python
def dec2bin(num):
    # return bin(num)  # 库函数实现
    l = []
    if num < 0:
        return '-' + dec2bin(abs(num))
    while True:
        num,remainder = divmod(num,2)
        l.append(str(remainder))
        if num == 0:
            return ''.join(l[::-1])
```

5.字符串查看ip是否符合

```python
import re
def checkIP(s):
    # 正则匹配
    # 对s进行匹配，逐个部分进行
    IP_compile = re.compile('^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$')
    if IP_compile.match(s):
        return True
    else:
        return False
```

6.统计字符串里数字字母空格和其他字符的个数

```python
def countThings(s):
    if not s:
        return []
    sum_c = 0
    sum_n = 0
    sum_s = 0
    sum_o = 0
    for i in s:
        if i.isalpha():
            sum_c += 1
        elif i.isdigit():
            sum_n += 1
        elif i == ' ':
            sum_s += 1
        else:
            sum_o += 1
    return sum_c,sum_n,sum_s,sum_o
```

7.输入的字符串是否全是数字

```python
def isNum(s):
    if not s:
        return False
    # return s.isdigit()
    # 这种写法，字符串只能为整数，不能有小数点
    for i in range(s):
        if not i.isdigit() :
            return False
    return True

def isNum(s):
    # 支持整个字符串验证，可以支持小数，Unicode的其他数字。
    try:
        float(s)
        return True
    except ValueError:
        pass
    try:
        import unicodedata
        unicodedata.numeric(s)
        return True
    except (TypeError,ValueError):
        pass
    return False
```

8.3*3矩阵转置

```python
def changeNum(nums):
    # 只能处理n*n的矩阵
    length = len(nums)
    for i in range(length):
        for j in range(i+1,length):
            nums[i][j],nums[j][i] = nums[j][i],nums[i][j]
    return nums

def changeNum(nums):
    # 可以装置n*m的矩阵
    return list(zip(*nums))
```

9.判断字符串是否可以由子串组成

```python

```

10.奇数偶数大小判断

```python

```

11.字符串中第一个出现一次的字符

```python
def firstUniqChar(s):
    if not s:
        return None
    # 使用set为了防止字符串过大，超时
    d= set()
    for i in s:
        if i not in d:
            if s.count(i) == 1:
                return i
            d.add(i)
    return None
```

12.最长回文串的长度

```python
def longestPalindrome(s):
    if not s:
        return s
    # 初始值
    n = len(s)
    longest_str = s[0]
    longest = 1
    
    for i in range(n):
        # 中心对称的两种情况
        str_odd,odd_len = findStr(s,n,i,i)
        str_new,new_len = findStr(s,n,i.i+1)
        
        curr = str_odd if odd_len > new_len else str_new
        
        if len(curr) > longest:
            longest = len(curr)
            longest_str = curr
    return longest,longest_str
def findStr(s,n,i,j):
    while i >= 0 and j < n and s[i] == s[j]:
        i -= 1
        j += 1
    return s[i+1:j],j-i-1
```

13.字符串反转

```python 
def reverse(s):
    # return s[::-1]
    ans = ''
    for i in range(len(s)-1,-1,-1):
        asn += s[i]
    return ans
```

14.数列求和

```python

```

15.字符串缩写

```python
if __name__ == '__main__':
    # 读取每个单词的首字母进行缩写。
    s = input().split()
    # ans = s[0]
    ans = ''
    for word in s:
        ans += word[0]
    print(ans)
```

```python
# 连续大写字母缩写，连续字母长度n>=4 如：AAABCDEFWW应该转换为AAA-FWW
# 除了大写字母以外其他的其他字符都忽略
def acronym(s,n):
    ans = ''
    tmp = i = index = 0
    while i < len(s):
        index = i
        if index == len(s)-1:
            ans += s[-1]
            break
        while not s[index].isupper(): 
            ans += s[index]
            index += 1
        i = index
        while index < len(s)-1 and ord(s[index])+1 == ord(s[index+1]):
            index += 1
            tmp = index - i + 1
        if tmp >= n:
            ans += s[i] + '-' + s[index]
        else:
            ans += s[i:index+1]
        i = index + 1
        tmp = 0
    return ans
```

16.KMP

```python
def gen_next(s2):
    k = -1
    n = len(s2)
    j = 0
    next_list = [0 for i in range(n)]
    next_list[0] = -1                           #next数组初始值为-1
    while j < n-1:
        if k == -1 or s2[k] == s2[j]:
            k += 1
            j += 1
            next_list[j] = k                    #如果相等 则next[j+1] = k
        else:
            k = next_list[k]                    #如果不等，则将next[k]的值给k
    return next_list


def match(s1, s2, next_list):
    ans = -1
    i = 0
    j = 0
    while i < len(s1):
        if s1[i] == s2[j] or j == -1:
            i += 1
            j += 1
        else:
            j = next_list[j]
        if j == len(s2):
            ans = i - len(s2)
            break
    return ans


if __name__ == '__main__':
    s1 = 'ababaacc'
    s2 = 'abaa'
    next_list = gen_next(s2)
    print(next_list)
    print(match(s1, s2, next_list))
```

17.把数组中值为0的都放在后面

```python
def putZero(nums):
    # 未保持非0元素的位置
    i = 0
    j = len(nums)-1
    while i < j:
        while i < len(nums) and nums[i] != 0:
            i += 1
        while j >= 0 and nums[j] == 0:
            j -= 1
        if i < j:
            nums[i],nums[j] = nums[j],nums[i]
            i += 1
            j -= 1
            continue
        else:
            break
def putZero(nums):
    # 非0元素相对位置不变
    for i in range(len(nums)):
        j = i
        if nums[i] == 0:
            j += 1
            while j < len(nums):
                if nums[j] != 0:
                    nums[i], nums[j] = nums[j], nums[i]
                    break
                j += 1
    return nums
```

18.二进制中1出现的次数

```python
def countofOne(s):
    # 给定一个整数，求其二进制中的1的个数
    count = 0
    while x > 0:
        count += 1
        x &= (x-1)
    return count
	
    while x > 0:
        if x & 1 == 1:
            count += 1
        x >>= 1
    return count
```

19.输出只存在一次的数字

```python
def singleNumber(nums):
    if not nums:
        return None
    # 以下为非空数组判断
    res = nums[0]
    for i in nums[1:]:
        res ^= i
    return res
```

20.对原始字符串进行左填充

```python
def test(s,n):
    #  zfill()方法返回指定长度的字符串，原字符串右对齐，前面填充0。
    return s.zfill(n)
	return s.ljust(n)# ljust(n,' ')可指定填充内容
	return s.rjust(n)
	return ' '*n+s
```

21.公倍数问题

```python

```

22.字符串奇偶互换

23.冒泡排序

```python
def BubbleSort(nums):
    if len(nums) <= 1:
        return nums
    # 传统
    for i in range(len(nums)-1):
        for j in range(len(nums)-1-i):
            if nums[j] > nums[j+1]:
                nums[j],nums[j+1] = nums[j+1],nums[j]
    return nums
	# 优化
    for i in range(len(nums)-1):
        flag = True
        for j in range(len(nums)-1-i):
            if nums[j] > nums[j+1]:
                nums[j],nums[j+1] = nums[j+1],nums[j]
                flag = False
        if flag:
            break
    return nums
```

24.1+2/3+3/5+4/7+....数列求和，输出结果

```python
def sumOfSerialN(n):
    # 求n为分子的数列的和
    if n == 1:
        return 1
    count = 0
    for i in range(1,n):
        count += i/(2*i-1)
  	return count
	# n为分母的数列的和
    if n == 1:
        return 1
    count = 0
    for i in range(1,n,2):
        count += ((i+1)/2)/i
    return count
```

25.输入一个字符串，不同的单词用空格隔开，把这些单词的首字母取出并大写输出，如输入：hello world，输出：HW

```python
def upperWord(s):
    s = s.split()
    res = ''
    
    for word in s:
        res += word[0].upper()
    return res
```

26.给三个数abc，能否在1000-9999之间找到一个数x，满足x%a=0且（x+1）%b=0且（x+2）%c=0，找不到这个数x就返回Impossible

```python
def findNumber(a,b,c):
    for i in range(1000,10000):
        if i%a == 0 and (i+1)%b == 0 and (i+2)%c == 0:
            return i
    return 'Impossible'
```

27.判断两个字符串是否是异位，比如abcn 和 banc是一对，anc和nac是一对，其实就是判断奇偶交换。 

```python
def isAnagram(s,t):
    if len(s) != len(t):
        return False
    return sorted(s) == sorted(t)
    # hash表
    from collections import defaultdict
    d = defaultdict(int)
    for i in range(len(s)):
        d[s[i]] = d[s[i]] + 1
        d[t[i]] = d[t[i]] - 1
    for val in d.values():
        if val != 0:
            return False
    return True
	#  Counter
    from collections import Counter
    return Counter(s) == Counter(t)
```

28.非负整数区间(1-n)1出现的次数：

```python
def findOne(n):
	count = 0
    m = 1 
    while m <= n:
        count += (n//m+8)//10 * m + (n//m%10 == 1)*(n%m+1)
        m *= 10
    return count
```

29.输出给定长度的回文子串，如4，输出1221

```python
def hString(n):
    if n%2 == 0:
        k = n//2
       	tmp = [x for x in range(1,k+1)]
        tmp = tmp +tmp[::-1]
    else:
        a,b = divmod(n,2)
        tmp = [x for x in range(1,a+1)]
        tmp = tmp + [a+1] + tmp[::-1]
    return ''.join(str(x) for x in tmp)
```

30.找出一位到九位数组成的所有奇数个数,其中每个数只能由0-7组成。比如1位的奇数1,3,5,7

```python
if __name__ == '__main__':
    sum = 4
    s = 4
    for i in range(2,10):
        print('%d'%(i-1),sum)
        if i <= 2:
            s *= 7
        else:
            s *= 8
        sum = s
    print('%d'%i,sum)
```

31.判断一个数是否是素数

```python
def is_prim(n):
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    i = 3
    while i*i<=n:
        if n%i == 0:
            return False
        i += 2
    return True
```

32.连续子数组的最大和

```python
def maxNums(nums):
    ans = nums[0]
    per_sum = 0
    for i in nums:
        if per_sum < 0:
            per_sum = i
        else:
            per_sum += i
        if per_sum > ans:
            ans = per_sum
    return ans
```

33.小写字母，大写字母，数字混合的字符串从大到小排序

```python
def SortString(s):
    # 冒泡
    s = list(s)
    for i in range(len(s)-1):
        flag = True
        for j in range(len(s)-1-i):
            if ord(s[j]) > ord(s[j+1]):
                s[j],s[j+1] = s[j+1],s[j]
                flag = False
        if flag:
            break
    return ''.join(i for i in s)
```

34.取出一串数字当中的偶数项

```python
def EvenNum(n):
    # 从低位到高位的偶数项
    n = str(n)[::-1]
    ans=''
    for i in range(1,len(n),2):
        ans += n[i]
    return int(ans)
```

35.1元一瓶水，两个瓶子兑换一瓶水，问n元钱总共能喝几瓶水

```python
def sumDrink(n):
    count = n
    while n >= 2:
        # n = n-2
        # n += 1
        # count += 1
        a,b = divmod(n,2)
        count += a
        n = a+b
    return count

def sumDrink2(n):
    count = n/2
    s = n/2 + n%2
    if s > 1:
        return count + sumDrink2(s)
    else:
        return count
if __name__ == '__main__':
    n = int(input())
    print(n+sumDrink2(n))
```

36.字符串大小写转换

```python
def lowerandupper(s):
    for i in range(len(s)):
        if s[i].isupper():
            s = s[:i] + s[i].lower() + s[i+1:]
        else:
            s = s[:i] + s[i].upper() + s[i+1:]
    return s
```

37.3*3矩阵转置

```python
def change(grids):
    for i in range(len(grids)):
        for j in range(i+1,len(grids[0])):
            grids[i][j],grids[j][i] = grids[j][i],grids[i][j]
    return grids
```

38.判断输入的字符串是不是可以由子串多次重复构成

```python
def checkString(s1,s2):
    n = len(s2)
    if len(s1)%n != 0:
        return False
    while len(s1) >= n :
        if s1[:n] == s2:
            s1 = s1[n:]
        else:
            return False
    if s1:
        return False
    return True
```

39.判断输入字符串是不是都是数字

```python
def checkNum(s):
    s = s.strip()
    for i in s:
        if i < '0' or i > '9':
            return False
    return True
```

40.掷n个骰子，求所有可能总和的概率

```python
def dp_probability(n,  dmax=6, dmin=1):
    # if s < n * dmin or s > n * dmax:
    #     return 0
    dp1 = [0] * (n * dmax + 1)
    
    # init dp[1, :]
    for i in range(1, dmax + 1):
        dp1[i] = 1
    # i: the number of dices
    for i in range(2, n + 1):
        dp2 = [0] * (n * dmax + 1)
        # j: range of i dices
        for j in range(dmin * i, dmax * i + 1):
                        # k: range of new added dice
            for k in range(dmin, dmax + 1):
                if j > k:
                    dp2[j] += dp1[j - k]
        # print dp2
        dp1 = dp2
    count = sum(dp1)
    print(count)
    for i in range(len(dp1)):
        dp1[i] = round(dp1[i]/count,5)
    return dp1
```

41.一个字符串，求所有重复的子串

```python
def repeatedStr(s):
    n = len(s)
    res = set()
    for i in range(n):
        for j in range(n-i):
            tmp = s[j:j+i+1]
            s_new = s[:j]+s[j+i+1:]
            if tmp in s_new and tmp not in res:
                res.add(tmp)
    return res
```

42.超级细菌,每秒产生一个细菌,小细菌四秒后也每秒产生一个细菌,问n秒后有多少细菌

```python
def brith(n):
    if n <= 3:
        return n
    dp = [0] * n
    dp[0] = 1
    dp[1] = 2
    dp[2] = 3       
    
    for i in range(3,n):
        dp[i] = dp[i-3]+dp[i-1]
    return dp[n-1]
```

Python join和+的区别

```
使用+会生成新的对象，使用join只是将原列表中的元素拼接起来，join效率更高。
```

43.最少出现删除

```python
from collections import defaultdict
while True:
    try:
        a = input()
        dd = defaultdict(int)
        for i in a:
            dd[i] += 1
        for i in dd:
            if dd[i] == min(dd.values()):
                a = a.replace(i, "")
        print(a)
    except:
        break
```

44.二进制下不同的位数

```python
def diffOfBIN(n1,n2):
    tmp = n1^n2
    count = 0
    while tmp !=0:
        tmp &= (tmp-1)
        count += 1
    return count
```



